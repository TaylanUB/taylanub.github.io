<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="/style.css" type="text/css" />
</head>
<body>
<p>Here's a funny little analogy I came up with to explain the difference between interpreters and compilers:</p>
<p>Say I have a machine that I want to operate, but it's very complicated. (This is the CPU, the instructions are complicated.)</p>
<p>I have an engineer who can operate the machine; I can speak to them in English and they figure out how to make the machine do that by pressing some buttons as I speak. (This engineer is the interpreter.)</p>
<p>But English is an inefficient language to communicate what to do with the machine so it all takes long. Since the engineer doesn't know the full task beforehand and instead does it all in small translated steps as I tell them the steps in English, it all takes very long.</p>
<p>A more efficient way is to first figure out the shortest sequence of buttons to push to get the whole job done. For this reason I have another engineer who can understand my English and translate the whole task I describe into the shortest possible sequence of button presses. This engineer can't operate the machine as I speak since they first need to hear the task from start to end, ponder on it a bit, and write down the result somewhere, but later that result can be used by anyone without that engineer around, and it will work very fast. This engineer is the compiler.</p>
</body>
</html>
